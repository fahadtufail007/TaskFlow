/*
This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at https://mozilla.org/MPL/2.0/.
*/

/*
Task Process
  Can present a text generated by an agent
  Can collect inpput from the user
  Makes use of steps and can be configured to follow different sequences
  
ToDo:
  
*/

import React, { useEffect, useState, useRef } from "react";
import { Typography, TextareaAutosize } from "@mui/material";
import usePartialWSFilter from "../../hooks/usePartialWSFilter";
import Paper from "@mui/material/Paper";
import withTask from "../../hoc/withTask";
import { replaceNewlinesWithParagraphs } from "../../utils/utils";

const TaskLLMIO = (props) => {
  const {
    log,
    entering,
    leaving,
    task,
    setTask,
    modifyTask,
    modifyState,
    stackPtr,
    //socketResponses,
    //setSocketResponses,
  } = props;

  const [responseText, setResponseText] = useState("");
  const [finalResponse, setFinalResponse] = useState(false);
  const [userInput, setUserInput] = useState("");
  const [showUserInput, setShowUserInput] = useState(false);
  const [userInputWordCount, setUserInputWordCount] = useState(0);
  const [responseTextWordCount, setResponseTextWordCount] = useState(0);
  const userInputRef = useRef(null);
  const responseTextRef = useRef(null);
  const paraTopRef = useRef(0);
  const [userInputHeight, setUserInputHeight] = useState(0);
  const [myTaskId, setMyTaskId] = useState();
  const [myLastState, setMyLastState] = useState("");
  const [socketResponses, setSocketResponses] = useState([]);

  // This is the level where we are going to use the task so set the stackPtr
  // Could have a setDepth function in withTask
  useEffect(() => {
    modifyTask({ stackPtr: stackPtr });
  }, []);

  // Reset the task. Allows for the same component to be reused for different tasks.
  // Probably always better to associate a component with a single task.
  useEffect(() => {
    if (task && !myTaskId) {
      log("Resetting", task.id)
      setMyTaskId(task.id);
      setResponseText("");
      setUserInput("");
      setUserInputWordCount(0);
      setResponseTextWordCount(0);
      if (!task.config?.nextStates) {
        // Default sequence is to just get response based on prompt text
        modifyTask({
          "config.nextStates": { start: "response", response: "wait", wait: "stop" },
        });
      }
      modifyState("start");
    }
  }, [task]);

  // This is asynchronous to the rendering so there may be conflicts where
  // state is updated during rendering and this impacts the parent
  // Probably needs to be moved outside of the component maybe into Redux
  useEffect(() => {
    const processResponses = () => {
      setSocketResponses((prevResponses) => {
        for (const response of prevResponses) {
          const text = response.text;
          const mode = response.mode;
          switch (mode) {
            case 'delta':
              setResponseText((prevResponse) => prevResponse + text);
              break;
            case 'partial':
              setResponseText(text);
              break;
            case 'final':
              setResponseText(text);
              setFinalResponse(true)
              break;
          }
          //console.log("response", response)
        }
        return []; // Clear the processed responses
      });
    };
    if (socketResponses.length > 0) {
      processResponses();
    }
  }, [socketResponses]);

  // I guess the websocket can cause events during rendering
  // Putting this in the HoC causes a warning about setting state during rendering
  usePartialWSFilter(task?.instanceId,
    (partialTask) => {
      //console.log("TaskLLMIO usePartialWSFilter partialTask", partialTask.response);
      setSocketResponses((prevResponses) => [...prevResponses, partialTask.response]);
    }
  )

  useEffect(() => {
    if (entering) {
      if (entering.direction === "prev" && entering.task.name === task.name) {
        if (task.config?.reenteringState) {
          modifyState(task.config.reenteringState)
        } 
      }
    }
  }, [entering]);

  // Sub_task state machine
  // Unique for each component that requires steps
  useEffect(() => {
    if (myTaskId && myTaskId === task.id) {
      const leaving_now =
        leaving?.direction === "next" && leaving?.task.name === task.name;
      const entering_now =
        entering?.direction === "prev" && entering?.task.name === task.name;
      const nextState = task.config.nextStates[task.state.current];
      let newState;
      //console.log("task.id " + task.id + " nextState " + nextState + " leaving_now " + leaving_now)
      log("TaskLLMIO State Machine State " + task.state.current + " nextState " + nextState + " leaving_now " + leaving_now)
      switch (task.state.current) {
        case "start":
          // Next state
          newState = nextState;
          // Actions
          break;
        case "display":
          setResponseText(task.config.response);
          break;
        case "response":
          if (task.state.current !== myLastState) {
            modifyTask({ update: true });
          } else if (finalResponse) { // waiting for response from websocket to end
            setFinalResponse(false)
            newState = nextState;
            // This should not be managed here - it is depending on websocket
            modifyTask({ "response.updated": false, "response.updating": false });
          }
          if (nextState === "input") {
            setShowUserInput(true);
          }
          break;
        case "input":
          // Actions
          // Wait until leaving then send input and wait for repsonse before going to next state
          if (leaving_now) {
            if (!task.response.updating) {
              // Need to automate management of response.updated (clear on request?)
              // id per request
              modifyTask({ update: true, "request.input": userInput });
            } else if (task.response.updated) {
              newState = nextState;
            }
          }
          break;
        case "wait":
          if (leaving_now && !task.state.done) {
            modifyTask({ "state.done": true });
            newState = nextState;
          }
          break;
        case "stop":
          // We may return to this Task and want to leave it again
          if (entering_now) {
            newState = "wait";
          }
          break;
        default:
          console.log("ERROR unknown state : ", task.state.current);
      }
      if (task.state.current !== newState) {
        if (newState) {
          modifyState(newState);
        }
        // Could use delta instead?
        // Useful if we want an action only performed once on entering a state
        setMyLastState(task.state.current);
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [leaving, task]);

  useEffect(() => {
    //console.log("task", task);
  }, [task]);

  // Adjust userInput input area size when input grows
  useEffect(() => {
    if (userInputRef.current) {
      setUserInputHeight(userInputRef.current.scrollHeight);
    }
    // filter removes empty entry
    const words = userInput.trim().split(/\s+/).filter(Boolean);
    setUserInputWordCount(words.length);
  }, [userInput, responseText]);

  useEffect(() => {
    const rect = responseTextRef.current?.getBoundingClientRect()
    // Avoid decreasing so it does not jitter
    if (rect?.top >= paraTopRef.current && rect.height > 100) {
      paraTopRef.current = rect.top;
    }
    // filter removes empty entry
    const words = responseText.trim().split(/\s+/).filter(Boolean);
    setResponseTextWordCount(words.length);
  }, [responseText]);

  return (
    <div style={{ display: "flex", flexDirection: "column" }}>
      {props.task.config?.instruction ? (
        <Paper
          elevation={3}
          style={{
            overflow: "auto",
            textAlign: "left",
            padding: "18px",
            marginBottom: "12px",
          }}
        >
          <Typography style={{ marginTop: "16px" }}>
            {props.task.config.instruction}
          </Typography>
        </Paper>
      ) : (
        ""
      )}
      {responseText ? (
        <>
          <Paper
            elevation={3}
            style={{
              overflow: "auto",
              maxHeight: `max(calc(100vh - ${userInputHeight + paraTopRef.current + 120}px), 200px)`,
              textAlign: "justify",
              padding: "16px",
            }}
            ref={responseTextRef}
          >
            {responseText.split("\\n").map((line, index) => (
              <Typography 
                style={{ marginTop: "16px" }} 
                key={index}
                className="text2html"
                dangerouslySetInnerHTML={{ __html: replaceNewlinesWithParagraphs(line) }}
              />
            ))}
          </Paper>

          <p
            style={{
              fontSize: "12px",
              color: "gray",
              margin: "4px 0 0 0",
              textAlign: "left",
            }}
          >
            {responseTextWordCount} words
          </p>
        </>
      ) : (
        ""
      )}
      {showUserInput ? (
        <div>
          <TextareaAutosize
            placeholder={props.task.request?.inputLabel}
            value={userInput}
            onChange={(e) => setUserInput(e.target.value)}
            style={{ marginTop: "16px" }}
            ref={userInputRef}
          />
          <p
            style={{
              fontSize: "12px",
              color: "gray",
              margin: "4px 0 0 0",
              textAlign: "left",
            }}
          >
            {userInputWordCount} words
          </p>
        </div>
      ) : (
        ""
      )}
    </div>
  );
};

export default withTask(TaskLLMIO);
