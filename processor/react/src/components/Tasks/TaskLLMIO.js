/*
This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at https://mozilla.org/MPL/2.0/.
*/

/*
Task Process
  Can present a text generated by an agent
  Can collect inpput from the user
  Makes use of steps and can be configured to follow different sequences
  
ToDo:
  
*/

import React, { useEffect, useState, useRef } from "react";
import { Typography, TextareaAutosize } from "@mui/material";
import usePartialWSFilter from "../../hooks/usePartialWSFilter";
import Paper from "@mui/material/Paper";
import withTask from "../../hoc/withTask";
import { replaceNewlinesWithParagraphs } from "../../utils/utils";

const TaskLLMIO = (props) => {
  const {
    log,
    entering,
    leaving,
    task,
    setTask,
    updateTask,
    updateStep,
    component_depth,
    //socketResponses,
    //setSocketResponses,
  } = props;

  const [responseText, setResponseText] = useState("");
  const [finalResponse, setFinalResponse] = useState(false);
  const [userInput, setUserInput] = useState("");
  const [showUserInput, setShowUserInput] = useState(false);
  const [userInputWordCount, setUserInputWordCount] = useState(0);
  const [responseTextWordCount, setResponseTextWordCount] = useState(0);
  const userInputRef = useRef(null);
  const responseTextRef = useRef(null);
  const paraTopRef = useRef(0);
  const [userInputHeight, setUserInputHeight] = useState(0);
  const [myTaskId, setMyTaskId] = useState();
  const [myStep, setMyStep] = useState("");
  const [myLastStep, setMyLastStep] = useState("");
  const [socketResponses, setSocketResponses] = useState([]);

  // This is the level where we are going to use the task so set the component_depth
  // Could have a setDepth function in withTask
  useEffect(() => {
    updateTask({ stackPtr: component_depth });
  }, []);

  // Reset the task. Allows for the same component to be reused for different tasks.
  // Probably always better to associate a component with a single task.
  useEffect(() => {
    if (task && !myTaskId) {
      log("Resetting", task.id)
      setMyTaskId(task.id);
      setResponseText("");
      setUserInput("");
      setUserInputWordCount(0);
      setResponseTextWordCount(0);
      if (!task.config?.nextStates) {
        // Default sequence is to just get response based on prompt text
        updateTask({
          "config.nextStates": { start: "response", response: "stop" },
        });
      }
      setMyStep("start");
    }
  }, [task]);

  // I guess the websocket can cause events during rendering
  // Putting this in the HoC causes a warning about setting state during rendering
  usePartialWSFilter(task?.instanceId,
    (partialTask) => {
      setSocketResponses((prevResponses) => [...prevResponses, partialTask.response]);
    }
  )

  // This is asynchronous to the rendering so there may be conflicts where
  // state is updated during rendering and this impacts the parent
  // Probably needs to be moved outside of the component maybe into Redux
  useEffect(() => {
    const processResponses = () => {
      setSocketResponses((prevResponses) => {
        for (const response of prevResponses) {
          const text = response.text;
          const mode = response.mode;
          switch (mode) {
            case 'delta':
              setResponseText((prevResponse) => prevResponse + text);
              break;
            case 'partial':
              setResponseText(text);
              break;
            case 'final':
              setResponseText(text);
              setFinalResponse(true)
              break;
          }
        }
        //console.log("setResponseText", responseText)
        return []; // Clear the processed responses
      });
    };
    if (socketResponses.length > 0) {
      processResponses();
    }
  }, [socketResponses]);

  useEffect(() => {
    if (entering) {
      if (entering.direction === "prev" && entering.task.name === task.name) {
        if (task.config?.reenteringState) {
          setMyStep(task.config.reenteringState)
        } 
      }
    }
  }, [entering]);

  // Sub_task state machine
  // Unique for each component that requires steps
  useEffect(() => {
    if (myTaskId && myTaskId === task.id) {
      const leaving_now =
        leaving?.direction === "next" && leaving?.task.name === task.name;
      const next_step = task.config.nextStates[myStep];
      //console.log("task.id " + task.id + " myStep " + myStep + " next_step " + next_step + " leaving_now " + leaving_now)
      log("MyStep " + myStep, task)
      switch (myStep) {
        case "start":
          // Next state
          setMyStep(next_step);
          // Actions
          break;
        case "response":
          if (myStep !== myLastStep) {
            updateTask({ send: true });
          } else if (finalResponse) { // waiting for response from websocket to end
            setFinalResponse(false)
            setMyStep(next_step);
          }
          if (next_step === "input") {
            setShowUserInput(true);
          }
          break;
        case "input":
          // Actions
          // Wait until leaving then send input and wait for repsonse before going to next state
          if (leaving_now) {
            updateTask({ send: true });
            setMyStep(next_step);
          }
          break;
        case "stop":
          if (leaving_now) {
            updateTask({ "state.done": true });
          }
          break;
        default:
          console.log("ERROR unknown step : " + myStep);
      }
      updateStep(myStep);
      //setTask((p) => {return {...p, step: myStep}});
      setMyLastStep(myStep); // Useful if we want an action only performed once in a state
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [leaving, myStep]);

  // Align task data with userInput input
  // Could copy this just before sending rather than on every update
  useEffect(() => {
    if (userInput) {
      updateTask({ "request.input": userInput });
      // Make available to other tasks an output of this task
      updateTask({ "output.input": userInput });
      //console.log("Updating input " + userInput);
    }
  }, [userInput]);

  // Adjust userInput input area size when input grows
  useEffect(() => {
    if (userInputRef.current) {
      setUserInputHeight(userInputRef.current.scrollHeight);
    }
    // filter removes empty entry
    const words = userInput.trim().split(/\s+/).filter(Boolean);
    setUserInputWordCount(words.length);
  }, [userInput, responseText]);

  useEffect(() => {
    const rect = responseTextRef.current?.getBoundingClientRect()
    // Avoid decreasing so it does not jitter
    if (rect?.top >= paraTopRef.current && rect.height > 100) {
      paraTopRef.current = rect.top;
    }
    // filter removes empty entry
    const words = responseText.trim().split(/\s+/).filter(Boolean);
    setResponseTextWordCount(words.length);
  }, [responseText]);

  return (
    <div style={{ display: "flex", flexDirection: "column" }}>
      {props.task.config?.instruction ? (
        <Paper
          elevation={3}
          style={{
            overflow: "auto",
            textAlign: "left",
            padding: "18px",
            marginBottom: "12px",
          }}
        >
          <Typography style={{ marginTop: "16px" }}>
            {props.task.config.instruction}
          </Typography>
        </Paper>
      ) : (
        ""
      )}
      {responseText ? (
        <>
          <Paper
            elevation={3}
            style={{
              overflow: "auto",
              maxHeight: `max(calc(100vh - ${userInputHeight + paraTopRef.current + 120}px), 200px)`,
              textAlign: "justify",
              padding: "16px",
            }}
            ref={responseTextRef}
          >
            {responseText.split("\\n").map((line, index) => (
              <Typography 
                style={{ marginTop: "16px" }} 
                key={index}
                className="text2html"
                dangerouslySetInnerHTML={{ __html: replaceNewlinesWithParagraphs(line) }}
              />
            ))}
          </Paper>

          <p
            style={{
              fontSize: "12px",
              color: "gray",
              margin: "4px 0 0 0",
              textAlign: "left",
            }}
          >
            {responseTextWordCount} words
          </p>
        </>
      ) : (
        ""
      )}
      {showUserInput ? (
        <div>
          <TextareaAutosize
            placeholder={props.task.request?.inputLabel}
            value={userInput}
            onChange={(e) => setUserInput(e.target.value)}
            style={{ marginTop: "16px" }}
            ref={userInputRef}
          />
          <p
            style={{
              fontSize: "12px",
              color: "gray",
              margin: "4px 0 0 0",
              textAlign: "left",
            }}
          >
            {userInputWordCount} words
          </p>
        </div>
      ) : (
        ""
      )}
    </div>
  );
};

export default withTask(TaskLLMIO);
