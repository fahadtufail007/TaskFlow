/* ToDo
-------
Create a script to convert the config files in-place

Add task type validation to websocket
Add task type validation to return from TaskFunctions
Rather than a JS hierarchy we might be better to use KeyV mapping e.g. meta-name etc 
  There is an issue of how to flatten the tasks
  Maybe Task keeps the internal structure
How to reference values from previous Tasks - available in "output"
  

Compare with similar systems
  LangChain - a framework for developing applications powered by language models.
    An abstraction above JS and Python
    Standard interface to models (could reuse this)
    Model output parsing sytem (could reuse this from TaskFunction)
    Provides stores for custom data e.g. text splitter
    The workflow in Chat2Flow is like an Agent in LangChain
  GPT-Index
    Should leverage this
  Open-AI Plugins
    This is LLM centric and will allow something similar
  Auto-GPT
    https://github.com/Significant-Gravitas/Auto-GPT
    This might be the close but their focus on autonomy is quite different
  https://github.com/modal-labs/quillman
    A complete audio chat app. Meant to serve as a starting point for your own language model-based apps.
  https://gradio.app/
    It would ideally be easy to use a Gradio component
    Embed in an iFrame
  Algovera
    Not open sourced (yet)
  
Backlog
-------

  Bugs
  -----
  Scrolling to view suggested_prompts in TaskChat
  Cleanup the initial authentication experience

  Features
  --------
    High Priority
    -------------
    multiple configuration files for the server
    Create infra directory
    Workflow features:
      Allow the user to specify the system prompt.
      Use a route for configuring: user, session, workflow, task
    Create a new route for the Client side user defaults. Manage in a global state. Send on all requests.
    Msgs could be loaded from the server. Similar to stepper - both have history.
    Allow task to start another task on server side (needs functional interface to api/task/start )
    Utility filters e.g. remove outer quotes, an ordered list.

    Tasks
    ----------
    MyAgents -> MyAgentConversation
    Multiple-choice above prompt to allow for quick refining of prompt e.g. use tutoiment, friendly, formal etc
    Templating with user defined variables
    Assistant to help understanding a problem rather than solving the problem
        Gamification to make learning more engaging
        An assistant to help explaining what the problem is
    Research assistant

    Low Priority
    ------------
    Move to TypeScript
    Way for tasks to register websocket event handlers
    Multiple language support 'i18next-http-middleware for server and react-i18next for client
    Defensive programming + logging
    Websocket for tasks (so server can drive) just send incremental info for the task
    Replace globalState with Redux
    When sending task instance only send diff (client keeps server copy, server keeps client copy)

Notes/Idea
-----
  Possible hierarchy of configuration:
  Defaults
    User (Route)
      Session
        Workflow (Route)
          User Workflow
            Session Workflow
              Task
                User Task
                  Session Task
  Asking the model to output in a format that would pass a test might be a software good way of constraining prmopts
    e.g. provide Python/JS code that the output should pass (e.g. a single word)
  How to interface with other apps with output from chat2flow ?
  Things will be integrated into existing clients (e.g. email)
  Educate the users to make use of the system

  Architecture
  ------------
    How to manage multiple interfaces for a Task
        Sub-directory with sub-components and a style or theme
    Tasks can be thought of as something like plugins, maybe there are patterns in that sort of software
        Implies catalog, installation, activation, configuration, updates, permissions, resource limits
        Requires a documented API, the basic principles at the moment:
            Use the Task object to pass information
            Manage task specific storage (e.g. files, user specific data) independently of the server Stores
            Through JS imports the TaskFunction has access to:
                config.mjs
                src/configdata.mjs (users, groups, workflows, components, agents, defaults, tasks)
                src/utils.mjs
                src/storage.mjs (messagesStore_async, sessionsStore_async, cacheStore_async, instancesStore_async, threadsStore_async, connections)
                src/websocket.js (wsSendObject)
                .env
    User defaults, workflow defaults etc can be tasks
    Could add middleware that tasks can use to modify input/output (similar to LangChain)
      Currently in the TaskFunction but should be easy to factor out when that makes sense
    How does a task monitor other tasks ? Callback to monitor a thread or a task (middleware catch updates to instance store)
      Maybe tasks are responsible for their own communication protocol 
      Pattern of having the parent own the state? That allows for communication.
      In React this is fairly easy. On the server this could be a pub-sub system. The common point is asynchronous messages.
    Should the geolocation be a task? It could still update the globalState on the client side
    How to call out to Python from the Task function
      "child process execution" with child_process library
      RabbitMQ for message passing good for a local model but do we need high speed, probably not.
      REST API would allow for remote etc, maybe better
      AMQP or MQTT would be more scalable.

  Issues
  ------
    Tasks run with full server rights. They should be sandboxed on the server.
        TaskFunction could run in a docker container
        Each TaskFunction could be a user on Linux
            User could run in a restricted environment e.g. firejail, bubblewrap
    Administation/monitoring of Chat2Flow, could ping a service that alerts to problems
    Is there a place for a scripting interfaec? Shell that understands Tasks.
    Structure of the Task object:
        * Shared between client and server
             `id` // this should be type not id, no type is component, id is like a path extendedType ?
             `component` // stack
             `component_depth` //stackPtr
             `next`  
             `forget`  
             `name`  // instead of label ?
             `label`  // replace wih name
             `instanceId` this is id
             `threadId`  
             `children`  
             `done`  
             `steps`  
             `step`  
             `next_step` 
             `menu`  // replaced by initiator
             `update_count` 
        * Server side only: (private to Task)
            * `APPEND_*`
            * `PREPEND_*` 
             `parent` // Replaced with parentType
             `parentId` 
             `parentInstanceId` // Replaced with parentId
             `agent` 
             `groups` 
             `sessionId` 
             `created` 
             `userId` 
             `prompt` 
             `assemble_prompt` // promptTemplate
             `last_change` 
             `update` 
             `delta_step` 
             `messages_template`
             `messages`

export { taskConverterToJson,  toTaskConverter };
&& sed -i -e 's/module\\\\.exports = {/\\\\export default {/g' -e 's/};/};/g' src/shared/taskConverter.mjs\"
 sed -i -e 's/module\.exports = {/export {/g' -e 's/};/};/g' src/shared/taskConverter.mjs

Here is the recommended structure from GPT-4:


{
  "id": "", // Unique identifier for the task (e.g., UUID)
  "type": "", // Task type or category, useful for handling tasks differently based on their natur
  "name": "", // Human-readable name or title of the task
  "description": "", // Brief description of the task and its purpose
  "status": "", // Current status of the task (e.g., "pending", "in-progress", "completed", "error")
  "priority": 0, // Priority level of the task, useful for determining the order of task execution
  "createdAt": "", // Timestamp when the task was created
  "updatedAt": "", // Timestamp when the task was last updated
  "completedAt": "", // Timestamp when the task was completed (if applicable)
  "input": {}, // Input data for the task, can be any JSON-serializable data
  "output": {}, // Output data from the task, can be any JSON-serializable data
  "error": null, // Any error message or details in case the task encounters an error
  "metadata": {}, // Additional metadata related to the task, can be any JSON-serializable data
  "dependencies": [], // Array of task IDs that this task depends on (if any) Could wait on these ?
  "nextTasks": [] // Array of task IDs that should be executed after this task (if any)
}

Break into: private (stays within Task when possible, both input and output), public (transparent input and output), meta (structure, function)

Private/public could just be a list like filtered_for_client
Challenge is passing tasks to functions -- request/response relative to task
Step -> state
// If the server and client share a copy then could communicate only the difference between last version sent. This could be in the communication protocol.

Use JSON Schema to define the object
https://quicktype.io/ 
https://github.com/bcherny/json-schema-to-typescript
Better to have a single place where transforms are don - not on the fly.
Load and transform then access natively

components.mjs is really a schema for Task - rename taskschema.mjs

Privacy: a parallel data structure that is a copy of Task but with booleans.
  Different services might have different privacy needs
Split into different objects: outer which is standard for all tasks inner which is custom? No but be clear where this partition is.

Pass as task and allow for sideband signals.

{
  "privacy" : {}, // privacy object
  "meta": {
    // Static
    "id": "", // Unique identifier for the task (e.g., UUID)
    "type": "", // the baseType and configuration context
    "baseType": "", // replaces will match with the stack entry at stackPtr
    "name": "", // human-readable name or title of the task
    "createdAt": "", // Timestamp when the task was created
    "completedAt": "", // Timestamp when the task was completed (if applicable)
    "threadId": "", // id of the original task
    "parentId" : "",
    "parentType" : "",
    "inititiator" : false, // Can this Task start a Taskflow (e.g. presented in menu)
    "groups": [], // should be permissions or access
    "userId": "",
    "stack" : [], 
    "versionExternal" : "", // version of this particular Task functionality
    "versionInternal" : "", // version of the general Task schema being used
    "routing" : [], path of URL/IP of where to send, future placeholder
    // Dynamic
    "updatedAt": "", // Timestamp when the task was last updated
    "priority": 0, // Priority level of the task, useful for determining the order of task execution
    "error": null, // Any error message or details in case the task encounters an error
    "nextTasks": [] // Array of task IDs that should be executed after this task (if any)
    "dependencies": [], // Array of task IDs that this task depends on (if any) Could wait on these ?
    "children": [], // Array of task IDs that this task created
    "updateCount": 0,
    "send": "", // equivalent of update - when to send the Task for update
    "stackPtr": 0, // index into the stack (should be the same as baseType)
  },
  "request": { // components should specify the request/response interface? Built on the fly
    // API to external functionality
    // Chat request:
    "agent": "", // need another name
    "prompt": "",
    "systemMessage" : "",
    "messages" : [],
    "temperature" : 0,
    "model" : "",
    "forget" : false,
    "inputLabel" : "",
    "version" : "",
  },
  "response":{
    // API from external functionality
    "text" : "",
    "userInput" : ""

  },
  "state": { // data the changes during the life of the Task
      // static
      "id" : ""
      // dynamic
      "done": false,
      "sessionId" : "",
      "deltaState" : "",
      "current" : "",
      "nextState" : "",
  },
  "config": {
      // Task specific example e.g.
      "promptTemplate" : [], // was assemble_prompt
      "systemMessageTemplate" : [],
      "messagesTemplate" : [],
      "suggestedPrompts" : [], 
      "welcomeMessage": "",
      "instruction": "",
      "nextStates": {}, // allows for a lookup table for simple state machine, currently "steps"
  },
  "input": {}, // Input data for the task, can be any JSON-serializable data
  "output": {}, // Output data from the task, can be any JSON-serializable data. The output is passed as input to the next Task(s)
}

To create schema:
