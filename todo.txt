/* ToDo
-------
Clicking next twice in summary exercise
  state might be the issues
  error not returned correctly from check4spelling
The Task Fuction could be a single JS module that is shared ?
  Maybe just the state machines
Not streaming text to summary
  Start streaming after update?
To get .vscode under version control we should have the taskflow directory as the top.
  This requires putting the config in the taskflow directory
  Clean up config at same time (move into hub)
We might need multiple levels of session:
  session processor-node
  user session
The diff is going to have to deal with deleting members - send diffUpdate and diffRemove
Ideally we want the same code for Task storage on Hub/React/NodeJs
  Could use @kvs/node-localstorage instead of 
  The Hub is different because it needs to manage multiple destinations
React has storage.js where activeTasks are stored using App.js
  Will need to extend with commands like remove, clear etc  

Internal/External IO is an important distinction
  A list of dependenceies/references that are monitored by the processor
    External outputs are monitored 
    What happens when a task is done - depends if monitoring the thread or instance
    Maybe the nextTask becomes available on the output then the monitoring task can decide to include this in 
    dependencies or not.

Demo of collaborative chat would be good.

Hub as a router rather than proxy
  The processor should not worry about destination ?
    It should request the destination as the environment not the processor.
      Not even  - Hub should update all activeTasks
    React
      destination is set in WebSocketContext.js and fetchTask.js
      Really just need to start or update. After update all copies should be updated.
      THe Hub needs to keep track of the tasks
Each processor needs a list of active Tasks
  Need to be able to push tasks to Processor
    Websocket commands task.processor.command 
  First implement on nodejs for: TaskChat
    React side just behaves as usual
    Hub has special treatment for TaskChat
    Nodejs has special treatment for TaskChat
    When hub receives request from React to start task it should send command to nodejs to also start task
      Nodejs needs to store active tasks
      Currently react sends task to nodejs though update
          Nodejs updates the task, this can hook into the current update function
          Eventualy the update function is like a kernel that processes tasks
            Loops over the tasks updating those that have changed.
              The task that is returned from the Task Function is used to update the Processor copy and send to Hub
              Hub then creates full task and sends as Update reply to React.
Refactor where information is stored
  The Hub knows which processors have which Functions through tasktemplates
  Hub routes functions then Processor no longer specifies destination
  At the moment the React TP decides on the destination processor
    Eventually the Hub should choose the processor based on the environments the Task uses

Hold all Task states at the top of React

Add function to remove last paragraph
  Interesting to explore how that might be done

Address is just a part of a task request
  Raises the idea of a task setting user information on the hub
    Or should there be a Task to do that?
            
We don't want all the Task data to be synchronized only the relevant data for the Task Function that is implemnted on the Task Processor. 
  Maybe a field in the Task is for local processor - this makes sense

Eventually do we move to using only web sockets? Maybe harder to debug.
  Sending Tasks to React will require websocket to at least trigger a request.
    This can allow things to "popup" into the UI

This argues for Tasks being distributed - different functions.
  If a Task passes through the Hub then we should track it in a keyv and maintain a distributed object
    Library called KVS (Key Value Storage) is suitable for both the browser and Node.js environments
  Only start tracking the task if it is on two or more processors
    Need to note this in the task

Currently nodejs saves instances of tasks, eventually they will pass through the hub.
The hub and nodejs should share utils?

When we start a task should we be able to add config info? For example the user.profile
  Could be added when it goes through the hub ? e.g. task.request.hub.user.profile
We need to sort out privacy - should only be implemented on the Hub
The Hub and Processors need to have secure communication, then identification is only controlled on the hub.

Task Hub
  TaskLLMIO_async needs access to instancesStore_async, threadsStore_async
  SubTaskLLM.mjs needs access to messagesStore_async (only used here)
    Should this just be in the task and stop using the storage in the API ?
  SubTaskLLM needs access to the user - should be part of the Task
    Need to move users data from SubTaskLLM.mjs to the task, then no longer using users in nodejs
    It is only used for the Dyad text
    Should probably be a generic templating approach with access to user data
      Building the system message in the Task
      Could rework this with the templating
Embedding functions in the template? Use ejs, could also have a template for the output e.g. post-processing.
  Where/how to manage variables? 
    Lookup only the required tasks not the whole thread.
  What about use across languages?
    Logic-less might be better: Handlebars
Harmonise the Task Processor
  The infrastructure provided by the Task Processor should perform the updates to the Task object as this allows for services to be provided upon value changes.
  In React withTask HOC and useTask state.
  A common JS module for managing the Task object. 
    What is generic to Task Processors and what is custom?
      React adds the concept of address/location.
When should we introduce Typescript?
  First try to simplify the code
Swagger for the API ?
Privacy feature of Task
Tests will allow for better code generation
If we prefix a T on Task parameters it would be easier to update with search & replace
  Better to use full path even in JXS e.g. task.name not name e.g in taskflows and stepper
How can we specify the UI in a more compact/easy way?
  https://github.com/rjsf-team/react-jsonschema-form
  A hook-based solution with minimal boilerplate: React Hook Form
How to have a task deal with compound react components
  config: list of components (with names) for display&input, mapping inputs to request.name.inputs
  config: list of components (with names) for display, mapping to response.name.outputs (if it is displaying a return)
  Basic pattern is: display -> input -> display -> input (can choose to use a subset)
  Could associate components with state of the Task ?
         * -> list of components that are active all the time
    state1 -> list of active components
    state2 -> list of active components
Consider how we would add a radio select box to a component
  Add the component and a config option to display or not
  Dynamic mapping of config to the input
  Standard way of mapping this to response. Make these available as variable in next Task (or state?)
Can we have the same React component present a new Task? I guess it does that automatically (carry the previous output along)
  In this case the patterns of display then input or input then display should be enough. TaskIO

Backlog
-------

  Bugs
  -----
  Scrolling to view suggested_prompts in TaskChat
  Cleanup the initial authentication experience

  Features
  --------
    High Priority
    -------------
    Simplify multiple configuration files for the NodeJS Task Processor
    Use a route for configuring: user, session, taskflow, task
    Create a new route for the Client side user defaults. Manage in a global state. Send on all requests.
    Msgs could be loaded from the NodeJS Task Processor. Similar to stepper - both have history.
    Allow task to start another task on NodeJS Task Processor side (needs functional interface to api/task/start )
    Utility filters e.g. remove outer quotes, an ordered list (use a standard templating library - ejs)
    When user interacts reset the counter to try to establish websocket on client

    Tasks
    ----------
    MyAssistant -> MyAssistantConversation
    Multiple-choice above prompt to allow for quick refining of prompt e.g. use tutoiment, friendly, formal etc
    Templating with user defined variables
    Assistant to help understanding a problem rather than solving the problem
      Gamification to make learning more engaging
      An assistant to help explaining what the problem is
    Research assistant
    Refactoring assistant (provide a duplicate code environment as the Task Environment)
      Example of the refactoring provided.
      LLM to explain the refactoring
      LLM to identify which files should be refactored
      Apply refactoring
        Syntax check as code is produced? 
        Fix for syntax errors
    Fetch prompt suggestion

    Low Priority
    ------------
    JWT connection between Task Hub and Processors (currently rely on Cloudflare)
    Move to TypeScript
    Way for tasks to register websocket event handlers
    Multiple language support 'i18next-http-middleware for NodeJS Task Processor and react-i18next for React Task Processor
    Defensive programming + logging
    Websocket for tasks (so NodeJS Task Processor can drive) just send incremental info for the task
    Replace globalState with Redux
    When sending task instance only send diff (React Task Processor keeps NodeJS Task Processor copy, NodeJS Task Processor keeps React Task Processor copy)
    Add task type validation to websocket
    Only display menu option if leaf is a real task

Notes/Idea
-----
  Possible hierarchy of configuration:
  Defaults
    User (Route)
      Session
        Taskflow (Route)
          User Taskflow
            Session Taskflow
              Task
                User Task
                  Session Task
  Asking the model to output in a format that would pass a test might be a software good way of constraining prmopts
    e.g. provide Python/JS code that the output should pass (e.g. a single word)
  How to interface with other apps with output from T@skFlow ?
    Windows accessibility APIs, such as UI Automation or MSAA (Microsoft Active Accessibility)
  Things will be integrated into existing clients (e.g. email)
  Educate the users to make use of the system
  One idea is to "flatten" the Task object on the Task Processor. Maybe this does not matter if access if wrapped by the Task processor.
  Writing the Hub and a generic Porcessor in Rust 

Architecture
------------
  How to manage multiple interfaces for a Task
      Sub-directory with sub-components and a style or theme
  Tasks can be thought of as something like plugins, maybe there are patterns in that sort of software
      Implies catalog, installation, activation, configuration, updates, permissions, resource limits
      Requires a documented API, the basic principles at the moment:
          Use the Task object to pass information
          Manage task specific storage (e.g. files, user specific data) independently of the NodeJS Task Processor Stores
  User defaults, taskflow defaults etc can be tasks
  Could add middleware that tasks can use to modify input/output (similar to LangChain)
    Currently in the TaskFunction but should be easy to factor out when that makes sense
  How does a task monitor other tasks ? Callback to monitor a thread or a task (middleware catch updates to instance store)
    Maybe tasks are responsible for their own communication protocol 
    Pattern of having the parent own the state? That allows for communication.
    In React this is fairly easy. On the NodeJS Task Processor this could be a pub-sub system. The common point is asynchronous messages.
  How to call out to Python from the Task function (better to create a Python Task and have the NodeJS Task Processor provide the environment?)
    "child process execution" with child_process library
    RabbitMQ for message passing good for a local model but do we need high speed, probably not.
    REST API would allow for remote etc, maybe better
    AMQP or MQTT would be more scalable.
  Keep server on nodejs processor - yes but for debug/admin/metrics etc
    Performance, utilization etc, a Processor Object for this (instead of Task)
    The debug features can be shared between processors e.g. just connect to keyv with activeTasks

Issues
------
  Tasks run with full NodeJS Task Processor rights. They should be sandboxed on the NodeJS Task Processor.
      TaskFunction could run in a docker container
      Each TaskFunction could be a user on Linux
          User could run in a restricted environment e.g. firejail, bubblewrap
  Administation/monitoring of T@skFlow, could ping a service that alerts to problems

Comparison with similar systems
----------------------------
  LangChain - a framework for developing applications powered by language models.
    An abstraction above JS and Python
    Standard interface to models (could reuse this)
    Model output parsing sytem (could reuse this from TaskFunction)
    Provides stores for custom data e.g. text splitter
    The taskflow in T@skFlow is like an Agent in LangChain
  GPT-Index
    Should leverage this
  Open-AI Plugins
    This is LLM centric and will allow something similar
  Auto-GPT
    https://github.com/Significant-Gravitas/Auto-GPT
    This might be the close but their focus on autonomy is quite different
  https://github.com/modal-labs/quillman
    A complete audio chat app. Meant to serve as a starting point for your own language model-based apps.
  https://gradio.app/
    It would ideally be easy to use a Gradio component
    Embed in an iFrame
  Algovera
    Not open sourced (yet)
    Langchain as backend
    Text as primary interface for specifying taskflowsTaskflow as first class object
  https://dust.tt/
    Chaining, version control, connections
  https://www.multi.tech/ (MultiFlow)
    taskflows powered by generative models
  https://www.kubeflow.org/
    Making deployments of machine learning (ML) taskflows on Kubernetes simple, portable and scalable.
  https://n8n.io/
    This is very close to what I want
    But n8n is fair-code distributed under the Sustainable Use License and the n8n Enterprise License.
    Commercially restricted by its authors
    This led me to Node-RED
  https://nodered.org/
  Meteor
     Meteor's data synchronization mechanism known as Distributed Data Protocol (DDP).
     Messages: DDP uses a small set of message types to communicate data changes, including added, changed, removed, ready, nosub, result, updated, and more. 



Test Plan
---------
Prefill tasks so we can work on a specifc part of the sequence (inherit taskflow with tasks? Needs better recursion)

A list of features that are manually tested
-------------------------------------------
  Features:
    general
      mobile
        screen rotation X
      websocket (with and without)
      permissions X
      authentication X
      parentType X
      user
        name X
        profile X
        interface X
    menu
      user specific X
      labels X
      menu closes after select
    Tasks
      TaskStepper
        next X
        back X
        skip back X
        expand multiple X
        close step X
        scrolling X
      TaskChoose
        error
      TaskLLMIO
        input
          word count X 
        response
          word count X
      TaskShowResponse
        error
      TaskChat
      TaskConversation
        scrolling (stop the bouncing) X
        agent specific
          dyad X
          forget 
        task specific
          config 
            messagesTemplate X
            promptTemplate X
            suggestedPrompts X
            welcomeMessage X
            nextTask X
            instruction X
            nextStates X
            oneThread X
            label X
            reentering
          request
            inputLabel 
            prompt X
            forget X
            agent X
            model X
          response
            userInput X
            text X
          model
            langModel X
            temperature X
            maxTokens X
            maxResponseTokens X
          error X
          errorTask X To test this uncomment line before return in processor/nodejs/Task/TaskLLMIO.mjs